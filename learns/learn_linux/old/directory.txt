Linux 是以树形目录结构的形式来构建整个系统的，可以理解为树形目录是一个用户可操作系统的骨架。
??从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。

	FHS standard
--tree

大部分目录结构是规定好了的（FHS 标准），是死的，当你掌握后，你在里面的一切操作都会变得井然有序。

FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。

FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等。

第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等等。

	directory path
./ 			当前目录
～			当前用户的 home 目录
../../			上一级的上一级

连续按两次 Tab 可以显示全部候选结果。

touch 			不会覆盖已有同名文件
mkdir -p		parent同时创建父目录（如果不存在该父目录）
			没有参数p就是找到目录新建最后一个
cp			copy 
cp -r(-R)		复制目录 表示递归复制，就是说有点“株连九族”的意思：\
rm 			remove files or directories
rm -f 			删除只读权限的文件 强制删除
rm -r(-R)		递归recursion
mv			move or rename files

------------------------------------------------------------------------
	rename								|
$ cd /home/shiyanlou/							|
									|
# 使用通配符批量创建 5 个文件:						|
$ touch file{1..5}.txt							|
									|
# 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:	|
$ rename 's/\.txt/\.c/' *.txt						|
									|
# 批量将这 5 个文件，文件名和后缀改为大写:				|
$ rename 'y/a-z/A-Z/' *.c						|
rename 是先使用第二个参数的通配符匹配所有后缀为 .txt 的文件		|
然后使用第一个参数提供的正则表达式将匹配的这些文件的 .txt 后缀替换为 .c	|
------------------------------------------------------------------------

cat 			顺序显示
tac 			倒序显示
	-n		加上行号
nl
	-b : 指定添加行号的方式，主要有两种：
		-b a:(all)表示无论是否为空行，同样列出行号("cat -n"就是这种方式)
		-b t:(text)只列出非空行的编号并列出（默认为这种方式）
	-n : 设置行号的样式，主要有三种：
		-n ln:(left null)在行号字段最左端显示
		-n rn:(right null)在行号字段最右边显示，且不加 0
		-n rz:(right zero)在行号字段最右边显示，且加 0
	-w : 行号字段占用的位数(默认为 6 位)
more 			显示在命令板里
less 			独立显示 像vim :q quit，退出后只剩自己的命令

head			默认10行	
tail 			-n 3 显示几行
			-f 时时监视
file 			查看文件类型

